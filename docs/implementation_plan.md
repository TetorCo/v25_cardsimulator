컴투스프로야구V25 카드 성장 시뮬레이터: 구현 계획서
문서 버전: 1.4
작성일: 2025년 9월 6일

1. 시스템 아키텍처
구조: 순수 클라이언트 사이드(Client-Side) 단일 페이지 애플리케이션 (SPA, Single Page Application)

동작 방식: 사용자가 브라우저에서 모든 데이터를 입력하고, 모든 계산 로직은 JavaScript를 통해 클라이언트 측에서 처리됩니다. 백엔드 서버나 데이터베이스는 사용하지 않습니다.

2. 기술 스택 (Tech Stack)
Frontend:

HTML5: 웹 페이지의 구조 정의.

CSS3 & Tailwind CSS: 반응형 레이아웃 및 모던한 UI 스타일링. CDN을 통해 로드하여 별도의 빌드 과정 없이 사용.

JavaScript (ES6+): 핵심 비즈니스 로직(능력치 계산, 비교, 렌더링) 구현. 프레임워크 없이 순수 Vanilla JS로 개발하여 경량화.

Visualization:

Chart.js: 카드 간 능력치 비교를 위한 레이더 차트 또는 바 차트 시각화. CDN을 통해 로드.

Deployment:

GitHub Pages: 정적(Static) 웹 페이지 호스팅을 위한 배포 환경.

3. 데이터 구조 정의
Card Object: 시뮬레이션의 기본 단위가 되는 카드 객체의 구조.

{
  id: 1, // 1, 2, 3 (UI 슬롯 식별자)
  isActive: true, // 시뮬레이션 활성화 여부
  playerInfo: {
    name: '이정후',
    team: '키움 히어로즈',
    year: '22',
    grade: '시그니처', // '라이브', '시즌', '임팩트' 등
    position: 'CF'
  },
  baseStats: {
    power: 80,
    contact: 85,
    speed: 82,
    fielding: 84,
    throwing: 81,
    // ... 투수 스탯
  },
  growthFactors: {
    enhancementLevel: 10, // 강화 레벨 (0-10)
    trainingDistribution: { // 훈련 포인트 분배
      power: 20,
      contact: 15,
      // ...
    }
  },
  setDeckEffect: {
    team: '키움 히어로즈', // 적용될 팀 덱
    year: '22', // 적용될 연도 덱
    grade: '시그니처', // 적용될 등급 덱
  },
  finalStats: { // 계산 결과가 저장될 객체
    power: 110,
    contact: 120,
    // ...
    ovr: 105.5
  }
}

4. 핵심 로직 및 알고리즘
4.1. 최종 능력치 계산 로직 (REQ-CALC-001)
카드의 최종 능력치는 '기본 능력치', '강화 보너스', '훈련 상승치', '세트덱 보너스'의 합으로 계산됩니다.

Formula:
FinalStat = BaseStat + EnhancementBonus + TrainingIncrease + SetDeckBonus

4.1.1. 강화 보너스 (EnhancementBonus):

각 카드 등급별, 강화 단계별로 적용되는 고정 능력치 보너스 데이터입니다.

타자 스탯 배열 순서: [파워, 정확, 선구, 주루, 인내, 수비]

투수 스탯 배열 순서: [구속, 제구, 구위, 변화, 지구력, 수비]

아래 데이터는 타자 카드의 강화 보너스를 기준으로 합니다.

const ENHANCEMENT_BONUSES_BY_GRADE = {
    '임팩트': [[0, 0, 0, 0, 0, 0],[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5],
                  [8, 6, 6, 6, 6, 6], [9, 9, 7, 7, 7, 7], [10, 10, 10, 8, 8, 8], [11, 13, 11, 9, 9, 9], [14, 14, 12, 10, 10, 10]],
    '시그니처': [[0, 0, 0, 0, 0, 0],[2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 4, 4], [6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10],
                  [14, 12, 12, 12, 12, 12], [16, 16, 14, 14, 14, 14], [18, 18, 18, 16, 16, 16], [20, 22, 20, 18, 18, 18], [24, 24, 22, 20, 20, 20]],
    '국가대표': [[0, 0, 0, 0, 0, 0],[2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 4, 4], [6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10],
                  [14, 12, 12, 12, 12, 12], [16, 16, 14, 14, 14, 14], [18, 18, 18, 16, 16, 16], [20, 22, 20, 18, 18, 18], [24, 24, 22, 20, 20, 20]],
    '골든글러브 4성': [[0, 0, 0, 0, 0, 0],[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5],
                      [8, 6, 6, 6, 6, 6], [9, 9, 7, 7, 7, 7], [10, 10, 10, 8, 8, 8], [11, 13, 11, 9, 9, 9], [15, 15, 13, 11, 11, 11]],
    '골든글러브 5성': [[0, 0, 0, 0, 0, 0],[2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 4, 4], [6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10],
                      [14, 12, 12, 12, 12, 12], [16, 16, 14, 14, 14, 14], [18, 18, 18, 16, 16, 16], [20, 22, 20, 18, 18, 18], [25, 25, 23, 21, 21, 21]],
    '라이브 4성': [[0, 0, 0, 0, 0, 0],[1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5],
                      [8, 6, 6, 6, 6, 6], [9, 9, 7, 7, 7, 7], [10, 10, 10, 8, 8, 8], [11, 13, 11, 9, 9, 9], [14, 14, 12, 10, 10, 10]],
    '라이브 5성': [[0, 0, 0, 0, 0, 0],[2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 4, 4], [6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10],
                      [14, 12, 12, 12, 12, 12], [16, 16, 14, 14, 14, 14], [18, 18, 18, 16, 16, 16], [20, 22, 20, 18, 18, 18], [24, 24, 22, 20, 20, 20]]
};

4.1.2. 훈련 상승치 (TrainingIncrease):

사용자가 trainingDistribution 객체에 분배한 포인트 값이 그대로 적용됩니다.

TrainingIncrease = trainingDistribution[statName];

4.1.3. 세트덱 보너스 (SetDeckBonus):

미리 정의된 SET_DECK_RULES 객체를 참조하여, 카드의 team, year 등의 조건과 일치하는 보너스 능력치를 찾아 더합니다.

4.2. OVR (Overall) 계산 로직 (REQ-CALC-002)
OVR은 포지션별 주요 능력치에 가중치를 부여하여 계산됩니다.

타자/투수 포지션별 가중치 테이블을 사전에 정의합니다.

Formula (타자 예시):
OVR = (power * 0.3) + (contact * 0.3) + (speed * 0.15) + (fielding * 0.15) + ...

4.3. 카드 비교 및 추천 로직 (REQ-UI-003)
비교 기준:

최종 OVR: 가장 직관적인 성능 지표.

핵심 능력치: 포지션에 가장 중요한 1~2개 능력치의 총합 (예: 클린업 타자의 파워+정확).

세트덱 기여도: 현재 사용자 덱에 더 높은 세트덱 스코어를 제공하는지 여부.

5. 모듈 분리 계획
main.js: 앱 초기화, 이벤트 리스너 등록 등 전체 흐름을 제어.

domManager.js: UI 요소(카드 슬롯, 입력 필드, 결과창)를 생성하고 업데이트하는 역할.

calculator.js: 모든 능력치 계산 로직(최종 능력치, OVR 등)을 포함하는 순수 함수 모듈.

chartManager.js: Chart.js를 이용해 비교 차트를 생성하고 업데이트하는 역할.

constants.js: 강화 보너스, 세트덱 규칙 등 변하지 않는 데이터를 관리.